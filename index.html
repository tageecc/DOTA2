<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - glTF 2.0</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                margin: 0px;
                overflow: hidden;
            }
        </style>
    </head>

    <body>
    <div id="container"></div>
        <script src="three.js-master/build/three.js"></script>
        <script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
        <script src="three.js-master/examples/js/loaders/GLTFLoader.js"></script>

        <script>
            var orbitControls = null;
            var container, camera, scene, renderer, loader;

            var cameraIndex = 0;
            var cameras = [];
            var cameraNames = [];
            var defaultCamera = null;
            var gltf = null;
            var mixer = null;
            var clock = new THREE.Clock();

            (function onload() {
            
                initScene();
                animate();

            })();

            function initScene() {

                container = document.getElementById( 'container' );

                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0x222222 );

                defaultCamera = new THREE.PerspectiveCamera( 45, container.offsetWidth / container.offsetHeight, 0.001, 1000 );

                //defaultCamera.up = new THREE.Vector3( 0, 1, 0 );
                scene.add( defaultCamera );
                camera = defaultCamera;

                var sceneInfo = {
                    name : 'BoomBox (PBR)', url : './model/crystal_maiden/crystal_maiden.gltf',
                    cameraPos: new THREE.Vector3(0.02, 0.01, 0.03),
                    objectRotation: new THREE.Euler(0, Math.PI, 0),
                    addLights:true,
                    addEnvMap: true
                }

                var spot1 = null;

                if (sceneInfo.addLights) {

                    var ambient = new THREE.AmbientLight( 0x222222 );
                    scene.add( ambient );

                    var directionalLight = new THREE.DirectionalLight( 0xdddddd );
                    directionalLight.position.set( 0, 0, 1 ).normalize();
                    scene.add( directionalLight );

                    spot1   = new THREE.SpotLight( 0xffffff, 1 );
                    spot1.position.set( 10, 20, 10 );
                    spot1.angle = 0.25;
                    spot1.distance = 1024;
                    spot1.penumbra = 0.75;

                    if ( sceneInfo.shadows ) {

                        spot1.castShadow = true;
                        spot1.shadow.bias = 0.0001;
                        spot1.shadow.mapSize.width = 2048;
                        spot1.shadow.mapSize.height = 2048;

                    }

                    scene.add( spot1 );

                }

                // RENDERER

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );

                if (sceneInfo.shadows) {
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                }

                container.appendChild( renderer.domElement );

                var ground = null;

                if (sceneInfo.addGround) {
                    var groundMaterial = new THREE.MeshPhongMaterial({
                            color: 0xFFFFFF
                        });
                    ground = new THREE.Mesh( new THREE.PlaneBufferGeometry(512, 512), groundMaterial);

                    if (sceneInfo.shadows) {
                        ground.receiveShadow = true;
                    }

                    if (sceneInfo.groundPos) {
                        ground.position.copy(sceneInfo.groundPos);
                    } else {
                        ground.position.z = -70;
                    }

                    ground.rotation.x = -Math.PI / 2;

                    scene.add(ground);
                }

                loader = new THREE.GLTFLoader();

            

                var url = sceneInfo.url;
               
                loader.load( url, function(data) {

                    gltf = data;

                    var object = gltf.scene;

                    if (sceneInfo.cameraPos)
                        defaultCamera.position.copy(sceneInfo.cameraPos);

                    if (sceneInfo.center) {
                        orbitControls.target.copy(sceneInfo.center);
                    }

                    if (sceneInfo.objectPosition) {
                        object.position.copy(sceneInfo.objectPosition);

                        if (spot1) {
                            spot1.position.set(sceneInfo.objectPosition.x - 100, sceneInfo.objectPosition.y + 200, sceneInfo.objectPosition.z - 100 );
                            spot1.target.position.copy(sceneInfo.objectPosition);
                        }
                    }

                    if (sceneInfo.objectRotation)
                        object.rotation.copy(sceneInfo.objectRotation);

                    if (sceneInfo.objectScale)
                        object.scale.copy(sceneInfo.objectScale);

                    if ( sceneInfo.addEnvMap ) {

                        var envMap = getEnvMap();

                        object.traverse( function( node ) {

                            if ( node.material && ( node.material.isMeshStandardMaterial ||
                                 ( node.material.isShaderMaterial && node.material.envMap !== undefined ) ) ) {

                                node.material.envMap = envMap;
                                node.material.needsUpdate = true;

                            }

                        } );

                        scene.background = envMap;

                    }

                    object.traverse( function ( node ) {

                        if ( node.isMesh ) node.castShadow = true;

                    } );

                    cameraIndex = 0;
                    cameras = [];
                    cameraNames = [];

                    if (gltf.cameras && gltf.cameras.length) {

                        var i, len = gltf.cameras.length;

                        for (i = 0; i < len; i++) {

                            var addCamera = true;
                            var cameraName = gltf.cameras[i].parent.name || ('camera_' + i);

                            if (sceneInfo.cameras && !(cameraName in sceneInfo.cameras)) {
                                    addCamera = false;
                            }

                            if (addCamera) {
                                cameraNames.push(cameraName);
                                cameras.push(gltf.cameras[i]);
                            }

                        }
                    
                    } 

                    var animations = gltf.animations;

                    if ( animations && animations.length ) {

                        mixer = new THREE.AnimationMixer( object );

                        for ( var i = 0; i < animations.length; i ++ ) {

                            var animation = animations[ i ];

                            // There's .3333 seconds junk at the tail of the Monster animation that
                            // keeps it from looping cleanly. Clip it at 3 seconds
                            if ( sceneInfo.animationTime )
                                animation.duration = sceneInfo.animationTime;

                            mixer.clipAction( animation ).play();

                        }

                    }

                    scene.add( object );

                }, undefined, function ( error ) {

                    console.error( error );

                } );

            orbitControls = new THREE.OrbitControls(defaultCamera, renderer.domElement);

            }


            function animate() {
                requestAnimationFrame( animate );
                if (mixer) mixer.update(clock.getDelta());
                if (cameraIndex == 0)
                    orbitControls.update();
                
                renderer.render( scene, camera );
            }

            var envMap;

            function getEnvMap() {

                if ( envMap ) {

                    return envMap;

                }

                var path = 'three.js-master/examples/textures/cube/Park2/';
                var format = '.jpg';
                var urls = [
                    path + 'posx' + format, path + 'negx' + format,
                    path + 'posy' + format, path + 'negy' + format,
                    path + 'posz' + format, path + 'negz' + format
                ];

                envMap = new THREE.CubeTextureLoader().load( urls );
                envMap.format = THREE.RGBFormat;
                return envMap;

            }


            function toggleAnimations() {

                var i, len = gltf.animations.length;

                for (i = 0; i < len; i++) {

                    var clip = gltf.animations[i];
                    var action = mixer.existingAction( clip );

                    if (action.isRunning()) {
                        action.stop();
                    } else {
                        action.play();
                    }

                }

            }

        </script>

    </body>
</html>
